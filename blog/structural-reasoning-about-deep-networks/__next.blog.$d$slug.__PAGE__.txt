1:"$Sreact.fragment"
2:I[5500,["/_next/static/chunks/3f8a10af67c1dfc0.js","/_next/static/chunks/f31544836cec3026.js","/_next/static/chunks/368a73e901fbb099.js"],"Image"]
6:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
7:"$Sreact.suspense"
3:T1272,<p>Working through Chapter 6, <em>Deep Feedforward Networks</em>, sharpened how I reason about neural networks. It did not expand my practical toolkit so much as refine my conceptual boundaries. After completing coursework like the DeepLearning.AI specialization, I was comfortable training multilayer perceptrons and reasoning about gradients. What this chapter clarified is that architecture is not just a tuning dimension—it is a structural assumption about the function class we are willing to search.</p>
<h2>Existence Does Not Imply Learnability</h2>
<p>I used to carry a simplified version of the Universal Approximation Theorem: neural networks can approximate any function. Chapter 6 makes explicit that this is an existence result about representational capacity, not a statement about efficiency or trainability.</p>
<p>Three distinctions became sharper for me. First, representational capacity: what functions are expressible in principle. Second, parameter efficiency: how many units are required to represent them. Third, learnability: whether optimization can reliably discover those parameters from data. The theorem addresses only the first.</p>
<p>This distinction matters when comparing shallow and deep networks. A single hidden layer network can approximate complex structured functions, but the width required may scale exponentially for certain compositional forms. Depth can reduce parameter count by reusing intermediate computations. In that sense, depth changes scaling behavior, not just capacity.</p>
<p>The most useful refinement was separating topology from optimization. The architecture defines the hypothesis class; gradient descent explores it imperfectly. The fact that a function is representable says nothing about whether it is practically learnable. That separation now anchors how I evaluate model design choices.</p>
<h2>Linear Layers, Factorization, and Parameter Efficiency</h2>
<p>One result I had not internalized before is what happens when we stack linear layers without nonlinearities between them. Two consecutive linear transformations collapse into a single linear transformation. Functionally, nothing changes.</p>
<p>But parameterization changes.</p>
<p>If a weight matrix $W \in \mathbb{R}^{m \times n}$ is factored as $W = AB$ with $A \in \mathbb{R}^{m \times r}$ and $B \in \mathbb{R}^{r \times n}$, we have expressed the same linear map with a rank constraint and potentially far fewer parameters when $r \ll \min(m, n)$. In other words, depth without nonlinearity induces a low-rank factorization.</p>
<p>I was familiar with LoRA in large language models, but I had mentally categorized it as a fine-tuning trick rather than a direct consequence of basic feedforward structure. Chapter 6 makes the underlying principle obvious: inserting a bottleneck linear layer is equivalent to imposing a low-rank constraint on the effective weight matrix. Two layers without an activation are simply a factorization.</p>
<p>This reframed low-rank adaptation for me. It is not an exotic modification; it is a structural parameterization choice. The architecture itself encodes a rank prior.</p>
<h2>Softplus vs ReLU</h2>
<p>The comparison between softplus and ReLU corrected an intuition I had inherited from smooth optimization: smoother functions should be easier to train. Softplus is differentiable everywhere with nonzero gradient, while ReLU is nondifferentiable at zero and flat for negative inputs. By a classical smoothness criterion, softplus seems preferable.</p>
<p>Empirically, ReLU often performs better. Chapter 6 provides a structural explanation. ReLU induces sparsity through hard gating, effectively selecting a subnetwork conditioned on the input. The resulting function is piecewise linear—globally nonlinear, but locally linear within each region. Optimization proceeds largely within these regions, with boundary crossings relatively rare in high dimensions.</p>
<p>Smoothness alone does not determine learnability. Geometry, sparsity, and gating behavior shape gradient flow and effective model complexity. That realization made me more cautious about mapping classical smooth optimization intuitions directly onto deep networks.</p>
<h2>A Shift in Emphasis</h2>
<p>Finishing Chapter 6 did not make me more confident in tuning models; it made me more precise in how I reason about them. I think less in terms of "can this network approximate the function?" and more in terms of parameter efficiency, structural priors, and the separation between representation and optimization. Neural networks feel less like universal approximators in the abstract and more like structured hypothesis classes with specific geometric and algebraic constraints.</p>0:{"buildId":"jIoxzGjDcOaYcJuNoFEAA","rsc":["$","$1","c",{"children":[[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https://alexleung.ca/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Blog\",\"item\":\"https://alexleung.ca/blog\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"Structural Reasoning About Deep Networks\",\"item\":\"https://alexleung.ca/blog/structural-reasoning-about-deep-networks\"}]}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"@id\":\"https://alexleung.ca/blog/structural-reasoning-about-deep-networks/#blogposting\",\"url\":\"https://alexleung.ca/blog/structural-reasoning-about-deep-networks/\",\"headline\":\"Structural Reasoning About Deep Networks\",\"description\":\"Chapter 6 sharpened how I think about architecture as a structural assumption, not just a tuning choice.\",\"keywords\":\"Deep Learning, Neural Networks, ML Theory\",\"image\":[\"https://alexleung.ca/assets/blog/structural-reasoning-about-deep-networks/cover.webp\"],\"datePublished\":\"2026-02-15T00:00:00.000Z\",\"dateModified\":\"2026-02-15T00:00:00.000Z\",\"author\":{\"@type\":\"Person\",\"@id\":\"https://alexleung.ca/#person\",\"name\":\"Alex Leung\"},\"publisher\":{\"@type\":\"Person\",\"@id\":\"https://alexleung.ca/#person\"},\"inLanguage\":\"en-CA\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://alexleung.ca/blog/structural-reasoning-about-deep-networks/\"},\"isPartOf\":{\"@type\":\"Blog\",\"@id\":\"https://alexleung.ca/blog/#blog\",\"name\":\"Blog | Alex Leung\"}}"}}],["$","div",null,{"className":"py-[var(--header-height)]","children":[["$","div",null,{"className":"section-title px-4","children":["$","h1",null,{"className":"block w-full text-center","children":"Structural Reasoning About Deep Networks"}]}],["$","article",null,{"className":"container mx-auto max-w-3xl px-5 mb-12","children":["$","div",null,{"className":"surface-static p-4 mx-auto","children":[["$","div",null,{"className":"mb-3 text-lg text-gray-300","children":"February 15, 2026"}],["$","div",null,{"className":"mb-6 flex flex-wrap gap-2","children":[["$","span","structural-reasoning-about-deep-networks-Deep Learning",{"className":"inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold border-white/20 text-gray-200","children":"Deep Learning"}],["$","span","structural-reasoning-about-deep-networks-Neural Networks",{"className":"inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold border-white/20 text-gray-200","children":"Neural Networks"}],["$","span","structural-reasoning-about-deep-networks-ML Theory",{"className":"inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold border-white/20 text-gray-200","children":"ML Theory"}]]}],["$","div",null,{"className":"overflow-hidden rounded-lg mb-6 sm:mx-0 md:mb-10","children":["$","$L2",null,{"src":"/assets/blog/structural-reasoning-about-deep-networks/cover.webp","alt":"Cover for Structural Reasoning About Deep Networks","width":1200,"height":630,"sizes":"(min-width: 1024px) 896px, 100vw","priority":false,"className":"aspect-[21/9] w-full object-cover shadow-sm"}]}],["$","div",null,{"className":"prose prose-invert max-w-none prose-headings:text-white prose-p:text-gray-300 prose-a:text-accent-link prose-a:no-underline hover:prose-a:text-accent-link-hover hover:prose-a:underline prose-strong:text-white prose-pre:border prose-pre:border-white/10 prose-pre:bg-black/50 md:prose-lg","dangerouslySetInnerHTML":{"__html":"$3"}}]]}]}]]}]],["$L4"],"$L5"]}],"loading":null,"isPartial":false}
4:["$","script","script-0",{"src":"/_next/static/chunks/368a73e901fbb099.js","async":true}]
5:["$","$L6",null,{"children":["$","$7",null,{"name":"Next.MetadataOutlet","children":"$@8"}]}]
8:null
